/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface BitlerServer {
  capabilities: {
    "action-requests.list": {
      input: {};
      output: {
        actionRequests: {
          kind: string;
          name: string;
          description: string;
        }[];
      };
    };
    "action-requests.describe": {
      input: {
        kind: string;
      };
      output: {
        actionRequest: {
          kind: string;
          name: string;
          description: string;
          schema?: unknown;
        };
      };
    };
    "context-items.list": {
      input: {};
      output: {
        contextItems: {
          kind: string;
          name: string;
          description: string;
        }[];
      };
    };
    "context-items.describe": {
      input: {
        kind: string;
      };
      output: {
        contextItem: {
          kind: string;
          name: string;
          description: string;
          schema?: unknown;
        };
      };
    };
    "events.list": {
      input: {};
      output: {
        events: {
          kind: string;
          name: string;
          group: string;
          description: string;
        }[];
      };
    };
    "capabilities.describe": {
      input: {
        kind: string;
      };
      output: {
        capability: {
          kind: string;
          name: string;
          group: string;
          description: string;
          input?: unknown;
          output?: unknown;
        };
      };
    };
    "capabilities.list": {
      input: {};
      output: {
        capabilities: {
          kind: string;
          name: string;
          group: string;
          description: string;
        }[];
      };
    };
    "capabilities.find": {
      input: {
        query: string;
        limit?: number;
      };
      output: {
        capabilities: {
          capability: {
            kind: string;
            name: string;
            group: string;
            description: string;
          };
          similarity: number;
        }[];
      };
    };
    "configs.list": {
      input: {};
      output: {
        configs: {
          kind: string;
          name: string;
          group?: string;
          description: string;
        }[];
      };
    };
    "configs.describe": {
      input: {
        kind: string;
      };
      output: {
        config: {
          kind: string;
          name: string;
          group?: string;
          description: string;
          schema?: unknown;
          hasValue: boolean;
        };
      };
    };
    "configs.set": {
      input: {
        kind: string;
        name: string;
        value?: unknown;
      };
      output: {};
    };
    "agents.list": {
      input: {};
      output: {
        agents: {
          kind: string;
          name: string;
          group?: string;
          description?: string;
        }[];
      };
    };
    "dialog.prompt": {
      input: {
        agent?: string;
        model?: string;
        systemPrompt?: string;
        discoverCapabilities?: number;
        discoverAgents?: number;
        capabilities?: string[];
        agents?: string[];
        context?: {
          [k: string]: unknown;
        };
        maxTokens?: number;
        conversationId?: string;
        prompt: string;
        dialog?: {
          role: "user" | "assistant" | "system";
          content: string;
        }[];
      };
      output: {
        response: string;
        context: {
          [k: string]: unknown;
        };
        requestId?: string;
        responseId?: string;
        actionRequests: {
          kind: string;
          description?: string;
          value?: unknown;
        }[];
      };
    };
    "dialog.create-new": {
      input: {
        /**
         * The title of the dialog
         */
        title: string;
        /**
         * The system prompt for the dialog
         */
        systemPrompt?: string;
        /**
         * The user prompt for the dialog
         */
        userPrompt?: string;
        /**
         * The capabilities that the agent will have access to
         */
        capabilities?: string[];
        /**
         * An intro shown to the user before the dialog starts
         */
        userIntro: string;
      };
      output: {
        success: boolean;
      };
    };
    "history.list": {
      input: {
        limit?: number;
      };
      output: {
        conversations: {
          id: string;
          name?: string;
          description?: string;
          pinned: boolean;
          createdAt: string;
          updatedAt: string;
        }[];
      };
    };
    "history.get": {
      input: {
        id: string;
      };
      output: {
        id: string;
        name?: string;
        description?: string;
        pinned: boolean;
        agent?: string;
        systemPrompt?: string;
        discoverCapabilies?: number;
        discoverAgents?: number;
        capabilities: string[];
        agents: string[];
        createdAt: string;
        updatedAt: string;
        messages: {
          id: string;
          role: string;
          content: string;
          createdAt: string;
        }[];
      };
    };
    "history.set": {
      input: {
        id: string;
        name?: string | null;
        description?: string | null;
        agent?: string | null;
        systemPrompt?: string | null;
        discoverCapabilies?: number;
        discoverAgents?: number;
        capabilities?: string[];
        agents?: string[];
      };
      output: {
        success: boolean;
      };
    };
    "history.add-messages": {
      input: {
        conversationId: string;
        role: string;
        content: string;
      }[];
      output: {
        ids: string[];
        success: boolean;
      };
    };
    "history.add-capabilities": {
      input: {
        /**
         * The capabilities to add to the conversation (kind). These will become available the next time the user makes a request.
         */
        capabilities: string[];
      };
      output: {
        success: boolean;
      };
    };
    "history.delete-messages": {
      input: {
        ids: string[];
      };
      output: {
        success: boolean;
      };
    };
    "aws.s3.list-buckets": {
      input: {
        awsProfile?: string;
      };
      output: {
        buckets: string[];
      };
    };
    "aws.s3.list-objects": {
      input: {
        awsProfile?: string;
        bucket: string;
        prefix?: string;
      };
      output: {
        bucket: string;
        keys: string[];
      };
    };
    "aws.s3.get-objects": {
      input: {
        awsProfile?: string;
        objects: {
          bucket: string;
          key: string;
        }[];
      };
      output: {
        objects: {
          bucket: string;
          key: string;
          content: string;
        }[];
      };
    };
    "notification.add": {
      input: {
        id?: string;
        title: string;
        message: string;
        actions?: {
          title: string;
          description?: string;
          /**
           * The kind of capability to run
           */
          kind: string;
          removeNotification?: boolean;
          /**
           * The input to the capability
           */
          data?: {
            [k: string]: unknown;
          };
        }[];
      };
      output: {
        id: string;
      };
    };
    "notification.list": {
      input: {};
      output: {
        notifications: {
          id: string;
          title: string;
          message: string;
          createdAt: string;
          actions: {
            id: string;
            title: string;
            description?: string;
            kind: string;
            removeNotification?: boolean;
            data?: unknown;
          }[];
        }[];
      };
    };
    "notification.remove": {
      input: {
        ids: string[];
      };
      output: {
        success: boolean;
      };
    };
    "notification.run-action": {
      input: {
        actionId: string;
      };
      output: {
        actionId: string;
        notificationId: string;
        success: boolean;
      };
    };
    "knowledge-base.list": {
      input: {};
      output: {
        knowledgeBases: {
          id: string;
          name: string;
        }[];
      };
    };
    "knowledge-base.create": {
      input: {
        name: string;
      };
      output: {
        id: string;
      };
    };
    "knowledge-base.add-document": {
      input: {
        knowledgeBaseId: string;
        documents: {
          documentId: string;
          title: string;
          content: string;
        }[];
      };
      output: {
        success: boolean;
      };
    };
    "knowledge-base.search-documents": {
      input: {
        query: string;
        limit?: number;
        knowledgeBaseIds?: string[];
      };
      output: {
        documents: {
          id: string;
          matches: {
            distance: number;
            chunkId: string;
            start?: number;
            end?: number;
          }[];
          title: string;
          content: string;
        }[];
      };
    };
    "timers.add": {
      input: {
        /**
         * Duration in seconds
         */
        duration: number;
        /**
         * Description of the timer
         */
        description?: string;
      };
      output: {
        /**
         * ID of the timer
         */
        id: string;
      };
    };
    "timers.remove": {
      input: {
        /**
         * ID of the timer
         */
        id: string;
      };
      output: {
        /**
         * True if the timer was removed
         */
        success: boolean;
      };
    };
    "timers.list": {
      input: {};
      output: {
        timers: {
          /**
           * ID of the timer
           */
          id: string;
          /**
           * Description of the timer
           */
          description?: string;
          /**
           * Duration in seconds
           */
          duration: number;
          /**
           * Start time of the timer
           */
          start: string;
        }[];
      };
    };
    "game.set-state": {
      input: {
        /**
         * The JSON representation of the game state as a string.
         */
        json: string;
      };
      output: {
        [k: string]: unknown;
      };
    };
    "game.roll-dice": {
      input: {
        /**
         * The number of sides on the dice.
         */
        sides: number;
      };
      /**
       * The number rolled on the dice.
       */
      output: number;
    };
    "json-documents.add-document": {
      input: {
        source: string;
        type: string;
        data?: unknown;
      };
      output: {
        id: string;
      };
    };
    "json-documents.find-documents": {
      input: {
        sources?: string[];
        types?: string[];
        limit?: number;
      };
      output: {
        id: string;
        source: string;
        type: string;
        createdAt: string;
        data?: unknown;
      }[];
    };
    "json-documents.get-sources": {
      input: {};
      output: string[];
    };
    "json-documents.get-types": {
      input: {};
      output: string[];
    };
    "json-documents.remove-documents": {
      input: {
        ids: string[];
        source?: string;
        from?: string;
        to?: string;
      };
      output: {
        success: boolean;
      };
    };
    "homeassistant.lights.get": {
      input: {
        /**
         * The room ids to turn off the lights in (allows multiple rooms)
         */
        rooms: string[];
        /**
         * The duration in seconds to transition to the new state
         */
        transition?: number;
      };
      output: {
        rooms: {
          id: string;
          all: {
            /**
             * The brightness of the light between 0 and 255
             */
            brightness?: number | null;
            color_temp_kelvin?: number | null;
            rgb_color?: number[] | null;
            friendly_name: string;
            lights?: string[] | null;
            entity_id?: string[] | null;
            icon?: string | null;
          };
        }[];
      };
    };
    "homeassistant.lights.turn-on": {
      input: {
        /**
         * The room ids to turn on the lights in (allows multiple rooms)
         */
        rooms: string[];
        /**
         * Number indicating the percentage of full brightness, where 0 turns the light off, 1 is the minimum brightness, and 100 is the maximum brightness.
         */
        brightness?: number;
        /**
         * Change brightness by a percentage.
         */
        brightnessStep?: number;
        /**
         * light temperature in kelvin
         */
        temperature?: number;
        /**
         * The color in RGB format. A list of three integers between 0 and 255 representing the values of red, green, and blue
         */
        color?: {
          r: number;
          g: number;
          b: number;
        };
        /**
         * The duration in seconds to transition to the new state
         */
        transition?: number;
      };
      output: {
        success: boolean;
      };
    };
    "homeassistant.lights.turn-off": {
      input: {
        /**
         * The room ids to turn off the lights in (allows multiple rooms)
         */
        rooms: string[];
        /**
         * The duration in seconds to transition to the new state
         */
        transition?: number;
      };
      output: {
        success: boolean;
      };
    };
    "homeassistant.setup.set-config": {
      input: {
        rooms: {
          id: string;
          names: string[];
          mediaPlayers?: string | null;
          lightGroup?: string | null;
          lights?: {
            id: string;
            name: string;
          }[];
        }[];
      };
      output: {
        success: boolean;
      };
    };
    "homeassistant.setup.get-config": {
      input: {};
      output: {
        rooms: {
          id: string;
          names: string[];
          mediaPlayers?: string | null;
          lightGroup?: string | null;
          lights?: {
            id: string;
            name: string;
          }[];
        }[];
      };
    };
    "spotify.search": {
      input: {
        query: string;
        types: {
          album: boolean;
          artist: boolean;
          playlist: boolean;
          track: boolean;
        };
      };
      output: unknown;
    };
    "music.play": {
      input: {
        spotifyUris: string[];
        /**
         * Room ID
         */
        room: string;
      };
      output: {
        success: boolean;
      };
    };
    "music.pause": {
      input: {
        /**
         * Room ID
         */
        room: string;
      };
      output: {
        success: boolean;
      };
    };
    "music.set-volume": {
      input: {
        /**
         * Volume level (0-1)
         */
        volume: number;
        /**
         * Room ID
         */
        room: string;
      };
      output: {
        success: boolean;
      };
    };
    "music.status": {
      input: {};
      output: {
        rooms: {
          id: string;
          player: {
            id: string;
            state: string;
            volume_level?: number;
            media_content_id?: string;
            media_content_type?: string;
            media_duration?: number;
            media_title?: string;
            media_artist?: string;
            media_album_name?: string;
            app_id?: string;
            shuffle?: boolean;
            repeat?: string;
            entity_picture?: string;
          };
        }[];
      };
    };
    "music.previous": {
      input: {
        /**
         * Room ID
         */
        room: string;
      };
      output: {
        success: boolean;
      };
    };
    "music.next": {
      input: {
        /**
         * Room ID
         */
        room: string;
      };
      output: {
        success: boolean;
      };
    };
    "music.resume": {
      input: {
        /**
         * Room ID
         */
        room: string;
      };
      output: {
        success: boolean;
      };
    };
    "linear.profile": {
      input: {};
      output: {
        id: string;
        name: string;
        email: string;
      };
    };
    "linear.my-issues": {
      input: {};
      output: {
        id: string;
        title: string;
      }[];
    };
    "linear.get-issue": {
      input: {
        /**
         * The ID of the issue to get, in the format AAA-123
         */
        identifier: string;
      };
      output: {
        issue: {
          id: string;
          identifier: string;
          priority?: number;
          priorityLabel?: string;
          title: string;
          addedToCycleAt?: string;
          branchName?: string;
          createdAt: string;
          completedAt?: string;
          cancelledAt?: string;
          estimate?: number;
          labelIds: string[];
          snoozedUntil?: string;
          startedAt?: string;
          updatedAt: string;
          description?: string;
        };
      };
    };
    "signal.get-contacts": {
      input: {};
      output: {
        contacts: {
          name: string;
          phone: string;
        }[];
      };
    };
    "signal.get-groups": {
      input: {};
      output: {
        groups: {
          name: string;
          id: string;
          internalId: string;
        }[];
      };
    };
    "signal.send": {
      input: {
        /**
         * The recipient's phone number
         */
        recipient: string;
        message: string;
        /**
         * Base64 encoded attachments ("<BASE64 ENCODED DATA>", "data:<MIME-TYPE>;base64<comma><BASE64 ENCODED DATA>", "data:<MIME-TYPE>;filename=<FILENAME>;base64<comma><BASE64 ENCODED DATA>")
         */
        attachments?: string[];
      };
      output: {
        success: boolean;
      };
    };
    "http.fetch": {
      input: {
        method: "GET" | "POST" | "PUT" | "DELETE";
        url: string;
        headers: {
          [k: string]: string;
        };
        body?: {
          contentType: string;
          content: string;
        };
      };
      output: {
        response: {
          statusCode: number;
          statusText?: string;
          headers: {
            [k: string]: string;
          };
          body: string;
        };
      };
    };
  };
  actionRequests: {
    "builtin.add-capabilities": {
      /**
       * The capabilities to add to the agent (kind)
       */
      schema: string[];
    };
    "builtin.create-dialog": {
      schema: {
        /**
         * The title of the dialog
         */
        title: string;
        /**
         * The system prompt for the dialog
         */
        systemPrompt?: string;
        /**
         * The user prompt for the dialog
         */
        userPrompt?: string;
        /**
         * The capabilities that the agent will have access to
         */
        capabilities?: string[];
        /**
         * An intro shown to the user before the dialog starts
         */
        userIntro: string;
      };
    };
  };
  contextItems: {
    "builtin.capabilities": {
      schema: {
        kind: string;
        name: string;
        group: string;
        description: string;
      }[];
    };
    "timers.current-time": {
      schema: string;
    };
    "game.state": {
      schema: {
        [k: string]: unknown;
      };
    };
    "homeassistant.rooms": {
      schema: {
        id: string;
        names: string[];
        mediaPlayers?: string | null;
        lightGroup?: string | null;
        lights?: {
          id: string;
          name: string;
        }[];
      }[];
    };
    "linear.user": {
      schema: {
        id: string;
        name: string;
      };
    };
    "linear.issues": {
      schema: {
        id: string;
        identifier: string;
        priority?: number;
        priorityLabel?: string;
        title: string;
        addedToCycleAt?: string;
        branchName?: string;
        createdAt: string;
        completedAt?: string;
        cancelledAt?: string;
        estimate?: number;
        labelIds: string[];
        snoozedUntil?: string;
        startedAt?: string;
        updatedAt: string;
        description?: string;
      }[];
    };
  };
  events: {
    "configs.updated": {
      input: {};
      output: {
        config: {
          kind: string;
        };
      };
    };
    "capabilities.updated": {
      input: {};
      output: {
        capability: {
          kinds: string[];
        };
      };
    };
    "context-items.updated": {
      input: {};
      output: {
        kind: string;
      };
    };
    "history.updated": {
      input: {};
      output: {
        id: string;
      };
    };
    "notification.removed": {
      input: {
        ids?: string[];
      };
      output: {
        id: string;
      };
    };
    "notification.created": {
      input: {};
      output: {
        id: string;
        title: string;
        message: string;
        actions: {
          id: string;
          title: string;
          description?: string;
        }[];
      };
    };
    "timer.created": {
      input: {};
      output: {
        id: string;
        description?: string;
        duration: number;
      };
    };
    "timer.triggered": {
      input: {};
      output: {
        id: string;
        description?: string;
        duration: number;
      };
    };
    "timer.updated": {
      input: {};
      output: {
        id: string;
        description?: string;
        duration: number;
        action: "created" | "updated" | "removed";
      };
    };
  };
}
